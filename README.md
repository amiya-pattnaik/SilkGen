
##	SilkGen - A Next Generation SilkTest  Framework

The SilkGen Framework gives you flexible architecture upon which, either you can choose the SilkGen approach or you can choose your own approach to develop your script in SilkTest through SilkGen.

#### Getting Started
If you are a first-time user and want to get up and running quickly, make sure you have  SilkTest 8.0 or above.

Here you have two paths, one is Framework path and the other one is your project working folder.
`Framework:` This is the location of the SilkGen framework in your local system.
![ScreenShot](https://github.com/amiya-pattnaik/snapshots/blob/master/SilkGen_framework_folder.png)

`Project:` This is the location of your project working folder in your local system. This is the place holder of your all project related files. You create your windows declaration, functions, data types etc. in your .inc file and give a reference of your all .inc files in the file Project_UseFiles.inc which is located in `\ProjectWorkingFolders\SilkTest\Includes\`
![ScreenShot](https://github.com/amiya-pattnaik/snapshots/blob/master/SilkGen_project_folder.png)

#### Configuration settings for application under test ( Property Settings )
This is the place where you need to set the configuration settings for your application under test.

Target Machine:	 The machine on which you wish to run your test. This can be local machine or a remote machine in the same network. If you wish to run locally then specify it as local. If you wish to run in a remote machine, specify either the hostname or the IP address of the remote machine. This field is not optional.
Note: If you are testing remotely, then in the remote machine the SilkTest Agent must be up and running before you start execution on it.

Default Browser: The browser in which you wish to run your application. Select the appropriate browse you wish from the drop down select box. If your application is non web based applications i.e. stand alone or client server, then select the value as none from the drop down select box. This field is not optional.

Remote Machine Error Directory: This is the location, where the snapshots of the application errors are stored in the remote machine. If test is running in a remote machine and a testcase is failed during execution, snapshots are taken and stored in this location of the remote machine (provided you are using SilkGen test approach to test your application. Kindly refer to the SilkGen test approach for more details. If you are not using SilkGen approach then you should use LogErrorSnapBmp () function directly in your testcase/function to avail this facility.) Once the test is completed these files are copied from the remote machine to the local machine to view the errors in the in the SilkTest IDE. SilkGen will copy the files from the remote machine to the Local machine; the user should have the Admin rights in the remote machine. Otherwise it will throw the error.

Local Machine Error Directory: This is the location of the error.bmp directory in local machine. If a testcase is failed during execution, snapshots are taken and stored in this said location of the local machine (provided you are using SilkGen test approach to test your application. Kindly refer to the SilkGen test approach for more details. If you are not using SilkGen approach then you should use LogErrorSnapBmp () function directly in your testcase/function to avail this facility.)  This path is optional to the user. You can leave this field as blank. If you are not specifying any value over here then the default location will be
\ProjectWorkingFolders\SilkTest\ErrorBmps\

Report Type: This is the type of customize report you want to generate along with SilkTest .res file. As of this current release the various reports available are XML, TXT. Select the desired reports type to be generated. If you have selected the option as none then in that case no customized reports will be generated. (Note: If you are using SilkGen approach, then preferably select report type as none. You can view your test results in more details in SilkTest .res file in a customized way by SilkGen Driver script).

TestSet Name: This is the module or functionality name of your application under test. This field is not optional.

TestSet Description: This is the description or note that you want to give for application under test. This field is not optional.

Debug Mode: This is to generate Log files during execution. This will have trace to all SilkGen functions/methods. Select the appropriate values (either 0 or 1) from the dropdown select box. If set to 0 (zero) then no Log files will be generated by SilkGen otherwise Log files will be generated. SilkGen will store the Log files in the `\ProjectWorkingFolders\SilkTest\Log\`

Results Directory: This is to redirect your SilkTest generated result files (.res) to the path specified in this field. If left blank the default location will be \ProjectWorkingFolders\SilkTest\Results\ This is optional. Preferably leave this field as blank so that your .res files will be automatically moved to above mentioned directory which is a single place holder for all result files.

#### Load SilkGen and Launch SilkTest
Once you have done with above steps, navigate to the `Executables` folder and run/click on  the `SILKGEN_START.bat` to load SilkGen and launch SilkTest. All the SilkGen files will be automatically loaded in the SilkTest memory and SilkTest IDE will be invoked. Now you can develop/debug/execute your script in SilkTest with the help of SilkGen.

#### Utilize the built in functions/methods in your AUT ( Libraries )
SilkGen provides you a wide range of built in function that you can directly use in your project to speed up your testing cycle. Varieties of functions available for Internet Explorer, HTML Table, Operating System (windows) calls, Date and Time manipulation, Window Information, Error/Snapshot, Data-Type manipulation, Excel database functions, String manipulation etc. For all libraries refer to the SilkGen_Library.txt file and source code can be found in `\Fremework\SilkTest\Includes`

#### Generate customized report along with SilkTest result file ( Reports )
If you have selected the option as XML or TEXT, in that case customized reports will be generated and this is the place from where you can view test results once execution is over. You can view the SilkGen customized report along with the SilkTest generated (.res) results file from `framework\SilkGen\ProjectWorkingFolders\SilkTest\Results`

#### A Glance to Customized report
SilkGen will generate two types of customized report either XML or TXT reports once execution is over.

XMLReport: The .xml reports are designed to address the larger section of audience like QA Manager, QA Lead, Client QA Manager and Client QA Lead, Project Manager etc... This will give you the detailed statistics of your testing. Anybody can view this result file across the globe on any platform on any browser. This has many bigger advantages in compare to SilkTest generated .res file. Such as, to view the .res file you need to have SilkTest installed on your machine (which requires a license cost), you can measure the individual testcase execution time (performance of each testcase), other information like when, which OS, who executed, actual error information, error in which module, which function, which line and many more in this report. The XML report is very light weight in compare to .RES file or .HTML. You can view this report on any platform on any browser. Below are the snapshots of one complete .XML report.

Note: The .XML files are generated based on the time stamp for example 160609_181159.xml is generated in DDMMYY_HHMMSS.xml format.

![ScreenShot](https://github.com/amiya-pattnaik/snapshots/blob/master/SilkGen_report1.png)
![ScreenShot](https://github.com/amiya-pattnaik/snapshots/blob/master/SilkGen_report2.png)
![ScreenShot](https://github.com/amiya-pattnaik/snapshots/blob/master/SilkGen_report3.png)
![ScreenShot](https://github.com/amiya-pattnaik/snapshots/blob/master/SilkGen_report4.png)

#### Folder Structure
`Framework:` This is the location of the SilkGen framework in your local system.
![ScreenShot](https://github.com/amiya-pattnaik/snapshots/blob/master/SilkGen_framework_folder.png)

`Project Under Test:`
![ScreenShot](https://github.com/amiya-pattnaik/snapshots/blob/master/SilkGen_project_folder.png)

You donâ€™t have to do anything with the Framework Folders / Files, only you have to deal with the Folders / Files that are available in the `\ProjectWorkingFolders\SilkTest.` This is the complete place holder for your project.

##### Data:
All the test data are stored in this location. You can have one or more Excel files as test data in this Data folder. For example, In MMS module the test data excel sheet would be MMS.xls and so on for the rest of the modules. You can have multiple sheets in one Excel file too.

##### ErrorBmps:
If a testcase is failed during execution, snapshots are taken and stored in this location of the local machine.

##### Includes:
All Window declarations, Methods, Functions, Object descriptions etc. specific to each window of your project / application are maintained over here. Include all your project related .inc files through USE statement in the Project_UseFiles.inc which is the startup file for your application under test. No need to include all your .inc files through Options -> Runtime -> UseFiles dialog.

##### INIFiles:
In automation, INI Files are used to store the intermediate data generated during execution of testcases. These intermediate data are used for verification purpose. The INI Files are generated by the scripts when parse function is called. Once INI File is generated, the parse function will get all the required data from the application and store it in the file. These stored data are the actual data and they are compared with the expected data (Fetched from the test data spread sheet).  You can store all project related .INI files in this location.

##### Log:
If you have selected debug mode as 1 from the dropdown select box in SilkGen, then Log files will be generated by SilkGen and will be available here. This will have trace to all SilkGen functions / methods.

##### OptionSets:
One or more option sets file can be created for your project and stored in this folder. An option set is opened on a test machine to automatically set the options required to successfully run a set of tests. For example you can have the main optionset file as YourProjectName_OptionSet.opt.

##### Results:
Results folder will have result file in the form of .XML, .TXT, .RES
Scripts: Scripts folder holds the entire script file that is being used by your project. You can keep any number of script files in this folder.

##### TestPlans:
TestPlans folder will have single Master Test Plan and multiple Sub-Plans corresponding to each module. For example YourProjectName_Master.pln is the Master Test Plan and the sub-plans will be in the name of each module for ex.Login.pln etc.

#### The SilkGen Approach

SilkGen unique test automation methodology that provides a roadmap for the user on how to choose, plan and develop a test automation project. The SilkGen approach also provides architecture upon which to build efficient data-driven tests. The SilkGen approach is completely based on the SilkTestâ€™s symbols which are the most advanced concept in SilkTest. Use symbols to define data that is shared by a group of tests in the TestPlan file. The data can be your application function name, method name, string etc. These data are passed to the SilkGenâ€™s Driver function. The symbol name can be any valid 4Test identifier name, but must begin with the $ character. The symbol value can be any text. When the TestPlan editor encounters the symbol, it expands it (in the same sense that another language expands). For example, the following TestPlan editor statement (1) defines a symbol named Color and assigns it the STRING value "Red" (2) defines a symbol named CloseAllBrowsers and assigns it the Function name â€œIE_CloseAllBrowsers" etc.
```
	$Color = "Red"
  $CloseAllBrowsers	 = {"IE_CloseAllBrowsers", {}}
  $CheckHeaderFooter = {"HeaderAndFooter", {$sSpreadsheet, $sSheet, $sTestCaseID}}

```

Refer to the sample Master TestPlan and Sub TestPaln file located in `\ProjectWorkingFolders\SilkTest\TestPlans\`
Note: If a symbol is listed in a TestCaseâ€™s argument list, but is not assigned a value before the TestCase is actually called, the TestPlan editor generates a runtime error that indicates that the symbol is undefined. To avoid this error, assign the symbol a value or a ? if the data is not yet finalized.

#############################################################################################################
##	SilkGen library functions
#############################################################################################################



#####	Internet explorer functions

Function:	SG_CloseAllBrowsers function
Action:		Close All Open Browsers on the machine in which the script is running.
Syntax:		SG_CloseAllBrowsers ()
Parameter: 	none
Returns:	void


Function:	SG_DeleteCookies function
Action:		Delete all Cookies on the machine in which the script is running.
Syntax:		SG_DeleteCookies ()
Parameter:	none
Returns:	void


Function:	SG_DeleteCookiesRestartBrowser function
Action:		Deletes temporary internet files and cookies and takes the browser down and back up (for IE 6.x only) on the machine in which the script is running.
Syntax:		SG_DeleteCookiesRestartBrowser ()
Parameter:	none
Returns:	void


Function: 	SG_DeleteTempInternetFiles function
Action:		Deletes temporary internet files and cookies (for IE 6.x only) on the machine in which the script is running.
Syntax:		SG_DeleteTempInternetFiles ()
Parameter:	none
Returns:	void


Function:	SG_FindBadImages function
Action:		Errors with URL and Image info for bad images found on any of the URLs in sURLLIst.
Syntax:		SG_FindBadImages (sURLListInFile)
Parameter:	sURLList: The text file containing the list of URLs to check. STRING.
Returns:	void


Function:	IE_FindOnPage function
Action:		Tests whether a string is present on the Internet Explorer page.
Syntax:		bFound = IE_FindOnPage (sFind)
Parameter:	sFind: The string to search for. STRING.
Returns:	bFound: TRUE if sFind is found on the current IE page, FALSE otherwise.


Function:	SG_PrintPage function
Action:		Prints the current web page.
Syntax:		SG_PrintPage ()
Parameter:	none
Returns:	void


Function:	SG_NavigateLinks function
Action:		Close All Open Browsers on the machine in which the script is running.
Syntax: 	SG_NavigateLinks (lsLinks, wStarting, laInvokeArgs )
Parameter: 	lsLinks: The list of link captions to click. LIST OF STRING.
		wStarting: Starting window for clicking links, will be invoked if does not exist (optional). WINDOW
		laInvokeArgs: Arguments for invoking wStarting, if needed (optional). LIST OF ANYTYPE
Returns:	void


Function:	SG_PageLoadTimes function
action:		Loads sPage iCount times and calculates the average page load time.
Syntax:		SG_PageLoadTimes (sPage, iCount, bDetail)
Parameter:	sPage: The URL of the web page to be timed. STRING
Parameter:	iCount: Number of times to time the page in order to calculate the average. Default is 1 (optional). INTEGER
Parameter:	bDetail: Whether or not to print out times for each iteration. Default is FALSE (optional). BOOLEAN
Returns:	void


Function:	SG_SaveAndVerifyPageSize function
Action:		Saves the page size and number of objects on the current web page and verifies them against the specified maximums.
Syntax:		SG_SaveAndVerifyPageSize (sPageName, sSavePath, sSizeCSVFile, sDetailCSVFile, [nMaxKB, iMaxObjects])
Parameter:	sPageName: Name to use when saving the page files. STRING.
Parameter: 	sSavePath: Directory to use when saving the page files. STRING.
Parameter: 	sSizeCSVFile: Comma Separated Value file where lines are written containing page size information and verification results. STRING.
Parameter: 	sDetailCSVFile: CSV file to store detailed page information such as the size of each object. STRING.
Parameter: 	iMaxObjects: Threshold for maximum objects that should be on the page. Default is 30 (optional). INTEGER.
Parameter: 	nMaxKB: Threshold for maximum page size (KB). Default is 50 (optional). NUMBER.
Returns:	void


Function:	SetHtmlTableRecognition function
Action:		Turns on recognition of tables and sets strength in DOM browser extensions.
Syntax:		SetHtmlTableRecognition (nStrength)
Parameter: 	nStrength: The strength from 0 to 1. NUMBER.
Returns:	void


Function:  	TurnHtmlTablesOff function
Action:		Turns off recognition of tables in DOM browser extensions.
Syntax:		TurnHtmlTablesOff ()
Parameter: 	none
Returns:	void


Function:  	TurnHtmlTablesOn function
Action:		Turns on recognition of tables in DOM browser extensions.
Syntax:		TurnHtmlTablesOn ()
Parameter: 	none
Returns:	void


Function:  	TurnTablesOff function
Action:		Turns off recognition of tables in Virtual Objects browser extensions.
Syntax:		TurnTablesOff (wWindow)
Parameter: 	wWindow: Window to address the turn off command to. WINDOW.
Returns:	void


Function:  	TurnTablesOn function
Action:		Turns on recognition of tables in Virtual Objects browser extensions.
Syntax:		TurnTablesOn (wWindow)
Parameter: 	wWindow: Window to address the turn on command to. WINDOW.
Returns:	void



#####	Operating System (windows) calls function

Function:   	MakeDir function
Action:     	Makes a directory if it does not exist. Requires the parent directory to exist.
Syntax:		MakeDir (sMakeDirPath, [bAgentProcess])
Parameter:  	sMakeDirPath: The fully qualified path of the directory to make. STRING.
Parameter:  	bAgentProcess: TRUE if called from an agent process - default is FALSE (optional). BOOLEAN.
Returns:    	void


Function:  	DeleteDir function
Action:     	Deletes a directory and its contents.
Syntax:		DeleteDir (sPath, [bMakeWritable])
Parameter: 	sPath: Fully qualified path of the directory to be deleted. STRING.
Parameter: 	bMakeWritable: If TRUE, directories files will be made writable and then deleted. Default is FALSE (optional). BOOLEAN.
Returns:   	void


Function:  	DeleteFile function
Action:     	Deletes a file if it exists.
Syntax:		DeleteFile (sFile, [bMakeWritable])
Parameter: 	sFile: Fully qualified file to delete. STRING
Parameter: 	bMakeWritable: If TRUE, file will be made writable and then deleted. Default is FALSE (optional). BOOLEAN.
Returns:   	void


Function:  	DeleteDirFiles function
Action:     	Deletes all files in a directory. Does not delete the directory.
Syntax:		DeleteDirFiles (sDeletePath)
Parameter: 	sDeletePath: Fully qualified path of the directory to be cleared. STRING.
Returns:   	void


Function:  	CopyOverwriteFile function
Action:     	Copies a file. If the file already exists in the destination directory, it is deleted before the copy occurs.
Syntax:		CopyOverwriteFile (sFileToCopy, sCopyToPath, [bAgentProcess])
Parameter: 	sFileToCopy: The fully qualified name of the file to copy from. STRING.
Parameter: 	sCopyToFile: The fully qualified name of the destination file. STRING.
Parameter: 	bAgentProcess: TRUE if called from an agent process - default is FALSE (optional). BOOLEAN.
Returns:	viod


Function:  	AttribNoReadOnly function
Action:     	Changes the attributes of the file to not be read only.
Syntax:		AttribNoReadOnly (sPath)
Parameter: 	sPath: Fully qualified filename to set attributes. STRING
Returns:   	void


Function:	GetNTUser function
Action:		Returns the current NT user name of the windows operating system.
Syntax:		sNTUser = GetNTUser()
Parameter:	none
Returns:	Returns the current NT user name in which the script is running. STRING.


Function:	GetThisComputerName function
Action:		Returns the name of the computer of the windows operating system.
Syntax:		sCompName = GetThisComputerName()
Parameter:	none
Returns:	Returns [sCompName] name of the computer in which the script is running. STRING.


#####	Date and Time function


Function:  	CreateCurrentDTSString function
Action:     	Returns a string based on current date time stamp for use in creating unique data.
Syntax:		sDateTime = CreateCurrentDTSString ()
Parameter: 	none
Returns:   	sDateTime: The 12-character date time stamp in mmddyyhhnnss format. STRING.



#####	window information function


Function:  	WaitForWindowGone function
Action:     	Waits for a window to disappear, up to the amount of time specified.
Syntax:		WaitForWindowGone (wToWaitFor, [iTimeout])
Parameter: 	wVerify: The window to wait for. WINDOW.
Parameter: 	iTimeout: The amount of time to wait for the window to appear. Defaults to window timeout (optional). INTEGER
Returns:   	void


Function:  	ClickCenter function
Action:     	Clicks in the center of an object, rather than the normal top left corner.
Syntax:		ClickCenter (wToClick)
Parameter: 	wToClick: The window to click. WINDOW.
Returns:   	void


Function:  	GetCenter function
Action:     	Returns the center point of an object.
Syntax:		pCenter = GetCenter (wCenter)
Returns:   	pCenter: The center point of the window. POINT.
Parameter: 	wCenter: The window to locate the center of. WINDOW.
Returns:   	void


Function:  	ReturnObjectsOfClassX function
Action:     	Returns all object children of the specified class, both declared and dynamically instantiated.
Syntax:		lwWindows = ReturnObjectsOfClassX (wParent, dClass, [iLevels])
Parameter: 	wParent: The window to be searched for objects. WINDOW.
Parameter: 	dClass: Class to be searched for. DATACLASS.
Parameter: 	iLevels: Number of levels to search for children (optional). INTEGER.
Returns:   	lwWindows: The child windows of the specified class. LIST OF WINDOW.


Function:  	GetChildren function
Action:    	Gets the children of the specified parent window to the specified number of levels deep.
Syntax:		lwChildren = GetChildren (wParent, iLevels)
Parameter: 	wParent: The parent window to get the children from. WINDOW.
Parameter: 	iLevels: The number of levels to return children from.  INTEGER.
Returns:   	lwChildren: The children of the window. LIST OF WINDOW.


function:  	VerifyExists (wToVerify, bExpectExists, [iTimeout])
Action:     	Verifies a specified window either does or does not exist in a given timeout.
parameter: 	wToVerify: The window which either will or will not exist. WINDOW.
parameter: 	bExpectExists: If TRUE, verify wToVerify exists. If FALSE, verify wToVerify does not exist. BOOLEAN
parameter: 	iTimeout: The amount of time to wait for the window to appear. Defaults to 1 second (optional). INTEGER
Returns:   	void


function:  	VerifyWindowsExist (lwVerify, [iTimeout, bVerbose])
Action:    	Verifies that the specified list of windows exist.
parameter: 	lwVerify: The list of windows to verify. LIST OF WINDOW.
parameter: 	iTimeout: The amount of time to wait for the windows to appear. Defaults to window timeout (optional). INTEGER.
parameter: 	bVerbose: If TRUE, positive verifications are logged. Defaults to TRUE (optional). BOOLEAN.
Returns:   	void


function:  	VerifyWindowExists (wVerify, [iTimeout])
Action:     	Verifies that a specified window exists.
parameter: 	wVerify: The window to verify. WINDOW.
parameter: 	iTimeout: The amount of time to wait for the window to appear. Defaults to window timeout (optional). INTEGER
Returns:   	void


#####	ERROR/SNAPSHOT function


Function:  	LogErrorSnapBmp function
Action:    	Captures a bitmap of the entire screen in a date time stamped file, and then logs the specified error.
	  	Default is the ProjectHome\SilkTest\ErrorBmps,
		else it will be stored in the path specified in the Propertes setting.
		The local machine and the remote machine's 'ErrorBmps' path should be the same in-order to view the bitmap
Syntax:		LogErrorSnapBmp (sErrorString, [bHaltTestcase])
Parameter: 	sErrorString: Informational message to be used in logging the error. STRING.
Parameter: 	bHaltTestcase: Switch that specifies whether to halt the testcase on error. Default is FALSE (optional). BOOLEAN
Returns:   	void



#####	DataType Functions


Function:	IsEnumType function
Action:		Checks whether the data type is of type Enumerater
Syntax:		bType = IsEnumType ( Type )
Parameter:	Type: the data-type to be checked. DATATYPE.
Returns:	Returns bType TRUE or FALSE. BOOLEAN.


Function:	IsSetType function
Action:		returns TRUE or FALSE if a set which contains all the members in the set domain.
Syntax:		bSet = IsSetType ( Type )
Parameter:	Type: The name of the set data type as defined in a type...is set declaration. DATATYPE.
Returns:	Returns bSet TRUE or FALSE. BOOLEAN.


Function:	ReturnDataType function
Action:		Attempt to assign a specified datatype. If successful, return the specified datatype
Syntax:		ReturnDataType (aValue [null])
Parameter:	aValue: [null]. Any value of type anytype. ANYTYPE.
Returns:	Returns the specified data-type. DATATYPE.


Function:	GetTypeOfElem function
Action:		Returns the datatype of the LIST elements
Syntax:		lMyList = GetTypeOfElem (l)
Parameter:	l: Used to declare a list variable. LIST.
Returns:	Returns lMyList, the type of data that is present in the LIST. ANYTYPE.


Function:	ResolveEnum function
Action:		Finds an element in the Enumerater
Syntax:		ResolveEnum (EnumType, sValue [null])
Parameter:	EnumType: The name of the Enumerater in which the element is to be searched. DATATYPE.
Parameter:	sValue: [null]. The element to be searched in the Enumerater. STRING.
Returns:	Returns the element if exists in the Enumerater else returns NULL. ANYTYPE.


Function:	ResolveSet function
Action:		Finds an element in the SET.
Syntax:		ResolveSet (SetType, sValue [null])
Parameter:	SetType: The name of the SET datatype in which the element is to be searched. DATATYPE.
Parameter:	sValue: [null]. The element to be searched in the SET dtatype. STRING.
Returns:	Returns the element if exists in the SET else returns NULL. ANYTYPE.


Function:	ConvertStrToType function
Action:		Convert a string to a specified datatype (can be STRING, NUMBER, BOOLEAN, ENUM, SET)
Syntax:		ConvertStrToType ( sValue null, VarType)
Parameter:	sValue : [null]. The string to convert. STRING.
Parameter:	VarType : Explicit type conversions require (Ex. STRING, NUMBER, BOOLEAN, ENUM, SET). DATATYPE
Returns:	Returns the sValue in the specified type. ANYTYPE.



#####	Excel Functions


Function:	Excel_Connect function
Action:		connects to the Excel sheet which is used as a database
Syntax:		HDATABASE Excel_Connect (sFileName)
Parameter:	sFileName: the Excel file to be connected. STRING.
Returns:		returns the handle of excel sheet. HDATABASE.


Function:	Excel_LoadTableRow function
Action:		Load the particular row value from the table according to the where clause to the record using ExcelMapping
Syntax:		Excel_LoadTableRow (aRecord, sFileName, sSheetName, lExcelMap, sWhere )
Parameter: 	sFileName  : The Spreadsheet name along with location {Ex: C:\Sample.xls}. STRING
Parameter: 	sSheetName : The Sheet name which is the table from which the value needs to be fetched. STRING
Parameter: 	sWhere     : The where clause against which the value will be fetched from the table. STRING
Parameter: 	aRecord    : The Record in which the values are stored after fetching. ANYTYPE
Parameter: 	lExcelMap  : ExcelMapping of the Column with the Record variables. EXCELMAP
Returns:	void

Example:

	[+] // type ExcelColumn is record				// Used to store the column's values of the original Excel Table			 
		STRING sCUSTNO
		STRING sCUSTNAME
		STRING sCUSTCITY
		STRING sCUSTDEPT
		// //Note:- This record should be declared outside of the function call

	[+] // LIST OF EXCELMAP lExcelMap = {...}			// Used to map the original Excel column name against the user defined record (ANYTYPE aRecord)
		{"CUSTNO",			"sCUSTNO"}
		{"CUSTNAME",		"sCUSTNAME"}
		{"CUSTCITY",		"sCUSTCITY"}
		{"CUSTJOINDATE",	"sCUSTJOINDATE"}


		// where CUSTNO, CUSTNAME, CUSTCITY etc are the Columns name of the SQL Table
		// where sCUSTNO, sCUSTNAME, sCUSTCITY etc are used to map these above Columns of the SQL Table


	STRING sFileName 	= "C:\CSI_1.1\SilkTest\Scripts\TestExcelTable.xls"
	ExcelColumn ExcelColumnData
	Excel_LoadTableRow (ExcelColumnData, sFileName, sSheet, lExcelMap, "CUSTNO = 1001")

	Print(ExcelColumnData)



Function:	Excel_LoadTableRows function
Action:		Load all the row values from the table according to the where clause which is optional to the list of record using ExcelMapping
Syntax:		Excel_LoadTableRows (laRecord, sFileName, sSheetName, lExcelMap, sWhere, nMaxRows)
Parameter: 	sFileName  : The Spreadsheet name along with location {Ex: C:\Sample.xls}. STRING
Parameter: 	sSheetName : The Sheet name which is the table from which the value needs to be fetched. STRING
Parameter: 	sWhere     : [Optional] The where clause against which the value will be fetched from the table. STRING
Parameter: 	laRecord   : The List of Records in which the values are stored after fetching. LIST OF ANYTYPE
Parameter: 	nMaxRows   : [Optional] The maximum number of rows to be fetched. If omitted all the rows will be selected. INTEGER
Parameter: 	lExcelMap  : ExcelMapping of the Column with the Record variables. EXCELMAP
Returns:	void

Example:
	[+] // type ExcelColumn is record				// Used to store the column's values of the original Excel Table			 
		STRING sCUSTNO
		STRING sCUSTNAME
		STRING sCUSTCITY
		STRING sCUSTDEPT
		// //Note:- This record should be declared outside of the function call

	[+] // LIST OF EXCELMAP lExcelMap = {...}			// Used to map the original Excel column name against the user defined record (ANYTYPE aRecord)
		{"CUSTNO",			"sCUSTNO"}
		{"CUSTNAME",		"sCUSTNAME"}
		{"CUSTCITY",		"sCUSTCITY"}
		{"CUSTJOINDATE",	"sCUSTJOINDATE"}


		// where CUSTNO, CUSTNAME, CUSTCITY etc are the Columns name of the SQL Table
		// where sCUSTNO, sCUSTNAME, sCUSTCITY etc are used to map these above Columns of the SQL Table


	STRING sFileName 	= "C:\CSI_1.1\SilkTest\Scripts\TestExcelTable.xls"
	LIST OF ExcelColumn lExcelColumnData
	Excel_LoadTableRows (lExcelColumnData, sFileName, sSheet, lExcelMap, "CUSTCITY = 'London'", 2)

	ListPrint(lExcelColumnData)
	Print(lExcelColumnData[1].sCUSTNO)
	Print(lExcelColumnData[2].sCUSTNAME)
	Print(lExcelColumnData[3].sCUSTCITY)



Function:	Excel_LoadTableRowsEx function
Action:		Load all the row values from more than one table (External tables) based on the SQL JOIN and the where clause (which is optional) -
		-  The result set is stored into the list of record using ExcelMapping.
		Note:- If sJoin is set to NULL, then you should not select any of the columns of the second table.i.e. in the Excel Mapping you you should not have any entries of the table's Column.

Syntax:		Excel_LoadTableRowsEx (laRecord, sFileName, sFrom, sJoin null, lExcelMap, sWhere, nMaxRows)
Parameter: 	sFileName  : The Spreadsheet name along with location {Ex: C:\Sample.xls}. STRING
Parameter: 	sFrom      : The First Sheet name which is the table from which the value needs to be fetched. STRING
Parameter: 	sJoin      : The SQL JOIN statement. STRING
Parameter: 	sWhere     : [Optional] The where clause based on which the value will be fetched from the table. STRING
            	{Ex : For "sWhere"  Correct format: [Students$].Name = [Dept$].Name and Wrong format : Students.Name = Dept.Name}
            	Here 'Students' and 'Dept' are the table names and 'Name' is the Column name
Parameter: 	laRecord   : The List of Records in which the values are stored after fetching. LIST OF ANYTYPE
Parameter: 	nMaxRows   : [Optional] The maximum number of rows to be fetched. If omitted all the rows will be selected. INTEGER
Parameter: 	lExcelMap  : ExcelMapping of the Column with the Record values
Returns:	void

Example:

	[+] // type ExcelColumnEx is record					// Used to store the column's values of the original Excel Table			 
		STRING sCUSTNO			//First table column
		STRING sCUSTNAME		//First table column
		STRING sCUSTDEPT		//Second table column
		STRING sCUSTJOINDATE	//Second table column
		// //Note:- This record should be declared outside of the function call

	[+] // LIST OF EXCELMAP lExcelMapEx = {...}			// Used to map the original Excel column name against the user defined record (ANYTYPE aRecord)
		{"Employee$.CUSTNO",		"sCUSTNO"}			//First table column mapping to sCUSTNO
		{"Employee$.CUSTNAME",		"sCUSTNAME"}		//First table column mapping to sCUSTNAME
		{"XEmployee$.CUSTDEPT",		"sCUSTDEPT"}		//Second table column mapping to sCUSTDEPT
		{"XEmployee$.CUSTJOINDATE",	"sCUSTJOINDATE"}	//Second table column mapping to sCUSTJOINDATE

		// where CUSTNO, CUSTNAME, CUSTCITY etc are the Columns name of the SQL Table
		// where sCUSTNO, sCUSTNAME, sCUSTCITY etc are used to map these above Columns of the SQL Table


	STRING sFileName 	= "C:\CSI_1.1\SilkTest\Scripts\TestExcelTable.xls"
	STRING sFrom		= "[Employee$]"
	STRING sJoin 		= "INNER JOIN [XEmployee$] ON [Employee$].CUSTNO = [XEmployee$].CUSTNO"
	STRING sWhere		= "[Employee$].CUSTNO = 1001"

	LIST OF ExcelColumnEx lExcelColumnDataEx
	Excel_LoadTableRowsEx (lExcelColumnDataEx, sFileName, sFrom, sJoin, lExcelMapEx, sWhere, 4)

	[+] //Output
		ListPrint(lExcelColumnDataEx)
		Print(lExcelColumnDataEx[1].sCUSTNO)
		Print(lExcelColumnDataEx[1].sCUSTNAME)
		Print(lExcelColumnDataEx[2].sCUSTDEPT)
		Print(lExcelColumnDataEx[2].sCUSTJOINDATE)



Function:	Excel_LoadTestCase function
Action:		Load the particular row value from the table according to the Test case ID to the record using ExcelMapping
Syntax:		Excel_LoadTestCase (aRecord, sFileName, sSheetName, lExcelMap, sTestCaseID)
Parameter: 	aRecord    : The Record in which the values are stored after fetching. ANYTYPE.
Parameter: 	sFileName  : The Spreadsheet name along with location {Ex: C:\Sample.xls}. STRING.
Parameter: 	sSheetName : The Sheet name which is the table from which the value needs to be fetched. STRING.
Parameter: 	lExcelMap  : ExcelMapping of the Column with the Record variables. EXCELMAP.
Parameter: 	sTestCaseID: The Test case ID against which the  row will be fetched from the table
Parameter: 	sColumnName: The column name, used for 'SQL where condition' against the 'sTestCaseID'. STRING.
Returns:	void

Example:

	[+] // type ExcelColumn is record				// Used to store the column's values of the original Excel Table			 
		STRING sCUSTNO
		STRING sCUSTNAME
		STRING sCUSTCITY
		// //Note:- This record should be declared outside of the function call

	[+] // LIST OF EXCELMAP lExcelMap = {...}			// Used to map the original Excel column name against the user defined record (ANYTYPE aRecord)
		{"CUSTNO",			"sCUSTNO"}
		{"CUSTNAME",		"sCUSTNAME"}
		{"CUSTCITY",		"sCUSTCITY"}


		// where CUSTNO, CUSTNAME, CUSTCITY etc are the Columns name of the SQL Table
		// where sCUSTNO, sCUSTNAME, sCUSTCITY etc are used to map these above Columns of the SQL Table

	STRING sFileName 	= "C:\CSI_1.1\SilkTest\Scripts\TestExcelTable.xls"
	STRING sSheet		= "Employee"


	ExcelColumn ExcelColumnData
	Excel_LoadTestCase (ExcelColumnData, sFileName, sSheet, lExcelMap, "CUSTNO", "1000")
	Print(ExcelColumnData)
	 //Note:- where "CUSTNO" refers to the Excel Column's name and "1000" refers to the row's value




Function:	Excel_TableRowCount function
Action:		Returns the number of rows in excel sheet based on the Pattern
Syntax:		iCount = Excel_TableRowCount (sFileName, sSheetName, sColumnName, sPattern)
Parameter: 	sFileName  : The Spreadsheet name along with location {Ex: C:\Sample.xls}. STRING.
Parameter: 	sSheetName : The Sheet name which is the table from which the value needs to be fetched. STRING.
Parameter: 	sColumnName : The column name of spread sheet/excel table. STRING.
Parameter: 	sPattern : To search for a specified pattern in a column. STRING
Returns:	Returns the number of rows in excel sheet. INTEGER.

Example:
	Print(Excel_TableRowCount("{HOST_GetEnv("PROJECT")}\Data\OrderCreation.xls",  "Order", "Test Case ID", "TC_"))




#####	DataBase Functions


Function: 	DB_QueryAll_Any function
Action: 	Executes all the valid query on the given database -
		The output of the Queries that are executed successfully are stored in the LIST OF ANYTYPE.
		Note:-  The output will only contain the records of the First column of the Table, which is of type LIST OF ANYTYPE.
Syntax:  	iCount = DB_QueryAll_Any (hdb, lsSQL, laValues)
Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:  	lsSQL: SQL query statement in LIST OF STRING format
Parameter:  	laValues: [inout] List of values of type ANYTYPE returned by SQL query
Returns:  	Returns the count of SQL query result. INTEGER

```Example:

	STRING sCon_string 	= "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	HDATABASE hdbc 		= DB_Connect (sCon_string)
	LIST OF STRING lsQuery 	= {"select * from Persons where P_Id = 100", "select * from Persons where P_Id = 800", "select *from XCUSTOMERS"}

	LIST OF ANYTYPE	 laQueryOutPut = {}

	DB_QueryAll_Any( hdbc, lsQuery, laQueryOutPut)
	Print(laQueryOutPut)

	 //output
	 //The output will only contain the records of the First column of the Table, which is of type LIST OF ANYTYPE.
```

Function: 	DB_QueryAll_Str function
Action: 	Executes all the valid query on the given database -
		The output of the Queries that are executed successfully are stored in the LIST OF ANYTYPE.
		Note:-  The output will only contain the records of the First column of the Table, which is of type LIST OF STRING.
Syntax:  	iCount = DB_QueryAll_Str (hdb, lsSQL, lsValues)
Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:  	lsSQL: SQL query statement in LIST OF STRING format
Parameter:  	lsValues: [inout] List of values of type STRING returned by SQL query
Returns:  	Returns the count of SQL query result. INTEGER

Example:

	STRING sCon_string 		= "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	HDATABASE hdbc 			= DB_Connect (sCon_string)
	LIST OF STRING lsQuery 		= {"select * from Persons where P_Id = 100", "select * from Persons where P_Id = 800", "select *from XCUSTOMERS"}

	LIST OF STRING	 lsQueryOutPut = {}

	DB_QueryAll_Str( hdbc, lsQuery, lsQueryOutPut)
	Print(lsQueryOutPut)

	 //output
	 //The output will only contain the records of the First column of the Table, which is of type LIST OF STRING.





Function: 	DB_QueryAll_ListAny function
Action: 	Executes all the valid query on the given database -
		The output of the Queries that are executed successfully are stored in the LIST OF LIST OF ANYTYPE.
		Note:-  The output will contain the records of all columns of the Table, which is of type LIST OF LIST OF ANYTYPE.
Syntax:  	iCount = DB_QueryAll_ListAny (hdb, lsSQL, llaValues)
Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:  	lsSQL: SQL query statement in LIST OF STRING format
Parameter:  	llaValues: [inout] List of values of type LIST OF ANYTYPE returned by SQL query
Returns:  	Returns the count of SQL query result. INTEGER

Example:

	STRING sCon_string 		= "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	HDATABASE hdbc 			= DB_Connect (sCon_string)
	LIST OF STRING lsQuery 		= {"select * from Persons where P_Id = 100", "select * from Persons where P_Id = 800", "select *from XCUSTOMERS"}

	LIST OF LIST OF ANYTYPE llaQueryOutPut = {}

	DB_QueryAll_ListAny( hdbc, lsQuery, llaQueryOutPut)
	Print(llaQueryOutPut)

	 //output
	 //Prints the output that will contain the records of all columns of the Table, which is of type LIST OF LIST OF ANYTYPE.





Function: 	DB_QueryAll_ListStr function
Action: 	Executes all the valid query on the given database -
		The output of the Queries that are executed successfully are stored in the LIST OF ANYTYPE.
		Note:-  The output will contain the records of all columns of the Table, which is of type LIST OF LIST OF STRING.
Syntax:  	iCount = DB_QueryAll_ListStr (hdb, lsSQL, llsValues)
Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:  	lsSQL: SQL query statement in LIST OF STRING format
Parameter:  	llsValues: [inout] List of values of type LIST OF STRING returned by SQL query
Returns:  	Returns the count of SQL query result. INTEGER

Example:

	STRING sCon_string 		= "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	HDATABASE hdbc 			= DB_Connect (sCon_string)
	LIST OF STRING lsQuery 		= {"select * from Persons where P_Id = 100", "select * from Persons where P_Id = 800", "select *from XCUSTOMERS"}

	LIST OF LIST OF STRING  llsQueryOutPut = {}

	DB_QueryAll_ListStr( hdbc, lsQuery, llsQueryOutPut)
	Print(llsQueryOutPut)

	 //output
	 //Prints the output that will contain the records of all columns of the Table, which is of type LIST OF LIST OF STRING.





Function: 	DB_QueryFirst_Any function
Action: 	Executes only the first valid query from lsSQL on the given database -
		The output of the Query that is executed successfully is stored in aValue.
		Note:-  The output will contain the first row's first column's value in aValue. ANYTYPE.
Syntax: 	bStatus = DB_QueryFirst_Any (hdb, lsSQL, aValue)
Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:  	lsSQL: SQL query statement in List of STRING format. LIST OF STRING lsSQL
Parameter:  	aValue: Value of returned by SQL query. ANYTYPE
Returns:  	bStatus : Returns FALSE when the query does not returs any value or there are no more rows. -
		- If the specified handle (hstmnt) is invalid, the function returns FALSE and an error. Otherwise TRUE. BOOLEAN.
Example:

	STRING sCon_string 		= "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	HDATABASE hdbc 			= DB_Connect (sCon_string)
	LIST OF STRING lsQuery 		= {"select * from Persons where P_Id = 100", "select * from Persons where P_Id = 800", "select *from XCUSTOMERS"}

	ANYTYPE aOut

	DB_QueryFirst_Any(hdbc, lsQuery, aOut)
	Print (aOut)

	 //output
	 //Prints the output that will contain the first row's first column's value in aValue. ANYTYPE.





Function: 	DB_QueryFirst_Str function
Action: 	Executes only the first valid query from lsSQL on the given database -
		The output of the Query that is executed successfully is stored in sValue.
		Note:-  The output will contain the first row's first column's value in sValue. STRING.
Syntax: 		bStatus = DB_QueryFirst_Str (hdb, lsSQL, sValue)
Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:  	lsSQL: SQL query statement in List of STRING format. LIST OF STRING lsSQL
Parameter:  	sValue: Value of returned by SQL query. STRING.
Returns:  	bStatus : Returns FALSE when the query does not returs any value or there are no more rows. -
		- If the specified handle (hstmnt) is invalid, the function returns FALSE and an error. Otherwise TRUE. BOOLEAN.
Example:

	STRING sCon_string 		= "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	HDATABASE hdbc 			= DB_Connect (sCon_string)
	LIST OF STRING lsQuery 		= {"select * from Persons where P_Id = 100", "select * from Persons where P_Id = 800", "select *from XCUSTOMERS"}

	STRING sOut

	DB_QueryFirst_Str(hdbc, lsQuery, sOut)
	Print (sOut)

	 //output
	 //Prints output will contain the first row's first column's value in sValue. STRING.





Function: 	DB_QueryFirst_ListAny function
Action: 	Executes only the first valid query from lsSQL on the given database -
		The output of the Queries that are executed successfully are stored in the laValue.
		Note:-  The output will only contain the first row's values of the Table, which is of type LIST OF ANYTYPE.
Syntax:  	bStatus = DB_QueryFirst_ListAny (hdb, lsSQL, laValues)
Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:  	lsSQL: SQL query statement in LIST OF STRING format
Parameter:  	laValues: [inout] List of values of type ANYTYPE returned by SQL query
Returns:  	bStatus : Returns FALSE when the query does not returs any value or there are no more rows. -
		- If the specified handle (hstmnt) is invalid, the function returns FALSE and an error. Otherwise TRUE. BOOLEAN.
Example:

	STRING sCon_string 		= "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	HDATABASE hdbc 			= DB_Connect (sCon_string)
	LIST OF STRING lsQuery 		= {"select * from Persons where P_Id = 100", "select * from Persons where P_Id = 800", "select *from XCUSTOMERS"}

	LIST OF ANYTYPE	 laQueryOutPut = {}

	DB_QueryFirst_ListAny ( hdbc, lsQuery, laQueryOutPut)
	Print(laQueryOutPut)

	 //output
	 //Prints The output will only contain the first row's values of the Table, which is of type LIST OF ANYTYPE.





Function: 	DB_QueryFirst_ListStr function
Action: 	Executes only the first valid query from lsSQL on the given database -
		The output of the Queries that are executed successfully are stored in the laValue.
		Note:-  The output will only contain the first row's values of the Table, which is of type LIST OF STRING.
Syntax:  	bStatus = DB_QueryFirst_ListStr (hdb, lsSQL, lsValues)
Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:  	lsSQL: SQL query statement in LIST OF STRING format
Parameter:  	lsValues: [inout] List of values of type ANYTYPE returned by SQL query
Returns:  	bStatus : Returns FALSE when the query does not returs any value or there are no more rows. -
		- If the specified handle (hstmnt) is invalid, the function returns FALSE and an error. Otherwise TRUE. BOOLEAN.
Example:

	STRING sCon_string 		= "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	HDATABASE hdbc 			= DB_Connect (sCon_string)
	LIST OF STRING lsQuery 		= {"select * from Persons where P_Id = 100", "select * from Persons where P_Id = 800", "select *from XCUSTOMERS"}

	LIST OF STRING	 lsQueryOutPut = {}

	DB_QueryFirst_ListStr ( hdbc, lsQuery, lsQueryOutPut)
	Print(lsQueryOutPut)

	 //output
	 //Prints The output will only contain the first row's values of the Table, which is of type LIST OF STRING.





Function:	DB_Insert function
Action:		Insert a new row or rows in a table
Syntax:		DB_Insert (hdb, sTable, lColumnValue)
Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:	sTable : the name of the database table. STRING.
Parameter:	lColumnValue : the list of column's value to be inserted. SQLCOLUMNVALUE
Returns:	void

Example:
	STRING sCon_string = "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	HDATABASE hdbc = DB_Connect (sCon_string)

	DB_Insert (hdbc, "Persons", lsqlInsert )
	 //where
	 //'Persons' refers to the table name

	 //lsqlInsert = {...}
		{"P_Id",101,0}
		{"FirstName","Amiya",0}




Function:	DB_Update function
Action:		Updates the specific column values i.e records in a table of a table
Syntax:		DB_Update (hdb, sTable, lColumnValue, sWhere)
Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:	sTable : the name of the database table. STRING.
Parameter:	lColumnValue : the list of column's value to be updated. SQLCOLUMNVALUE
Parameter:	sWhere : the where condition against which the table will be updated
Returns:	void

Example:
	STRING sCon_string = "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	HDATABASE hdbc = DB_Connect (sCon_string)

	DB_Update (hdbc, "Persons", lsqlUpdate, "P_Id = 111")
	 //where
	 //'Persons' refers to the table name

	// lsqlUpdate = {...}
		{"P_Id",101,0}
		{"FirstName","Amiya",0}

	 //P_Id = 111 refers to the where cluase i.e columnname = columnvalue






Function:	DB_Execute function
Action:		Sends a list of SQL statements to the specified database for execution.
Syntax:		DB_Execute (hdb, lsSQL)
Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:	lsSQL: list of SQL statement to the specified database for execution. LIST OF STRING.
Returns:	void

Example:

	STRING sCon_string = "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	HDATABASE hdbc = DB_Connect (sCon_string)

	[+] // LIST OF STRING lsQuery = {...}
		"select * from Persons where P_Id = 901"
		"select * from Persons where P_Id = 101"
		"select *from Employee"

	 //DB_Execute(hdbc, lsQuery)



Function:  	SQ_ExecuteSQLScript function
Action:		Excutes a SQL script on the specified database
Syntax:		DB_ExecuteSQLScript(sODBC_ConnectString, sFilename)
parameter: 	sODBC_ConnectString: The ODBC connection string. STRING.
parameter: 	sFilename: The SQL file to execute. STRING.
Returns:     	viod

Example:

	STRING sCon_string = "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	 //DB_ExecuteSQLScript(sCon_string, "C:\CSI_1.1\SilkTest\Scripts\Test.sql")





Function: 	DB_QueryFirst_Record function
Action: 		Executes only the first valid query from lsSQL on the given database -
 			The output of the Query that is executed successfully is stored in aRecord.
 			Note:-  The output will contain the first row's first column's value in aRecord. ANYTYPE.
Syntax: 		iCount = DB_QueryFirst_Record (hdb, lsSQL, lQueryMap, aRecord, bUpdateRecord)

Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:  	lsSQL: SQL query statement in List of STRING format. LIST OF STRING lsSQL
Parameter:  	lQueryMap: SQL Mapping of the Column with the Record values, SQLQUERYMAP. LIST OF SQLQUERYMAP
Parameter:  	aRecord: Value of returned by SQL query. ANYTYPE Record.
Parameter: 	bUpdateRecord: [Optional] If TRUE, then the Record i.e. aRecord will be Initialize, else not.
Returns:  	iCount : Returns the count of SQL query result. INTEGER

Example:
	[+] // type SQLColumn is record			// Used to store the column's values of the original SQL Table
		STRING sCUSTNO
		STRING sCUSTNAME
		STRING sCUSTCITY
		// Note:- This record should be declared outside of the function call

	[+] // LIST OF SQLQUERYMAP lSqlQueryMap = {...}	// Used to map the original SQL column name against the user defined record (ANYTYPE aRecord)
		{"CUSTNO",			"sCUSTNO"}
		{"CUSTNAME",		"sCUSTNAME"}
		{"CUSTCITY",		"sCUSTCITY"}

		// where CUSTNO, CUSTNAME, CUSTCITY etc are the Columns name of the SQL Table
		// where sCUSTNO, sCUSTNAME, sCUSTCITY etc are used to map these above Columns of the SQL Table



	STRING sCon_string = "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	LIST OF STRING lsQuery = {"select * from XCUSTOMERS where CUSTNO = 900", "select * from XCUSTOMERS where CUSTNO = 1006", "select *from XCUSTOMERS"}

	HDATABASE hdbc = DB_Connect (sCon_string)
	//print(hdbc)

	SQLColumn SQLColumnData
	DB_QueryFirst_Record (hdbc, lsQuery, lSqlQueryMap, SQLColumnData)

	Print (SQLColumnData.sCUSTNO)
	Print (SQLColumnData.sCUSTNAME)
	Print (SQLColumnData.sCUSTCITY)

	[+] // Output:
		Prints the CUSTNO of first record





Function: 	DB_QueryAll_Record function
Action: 		Executes all the valid query from lsSQL on the given database -
			The output of the Query that are executed successfully are stored in laRecords.
Syntax: 		iCount = DB_QueryAll_Record(hdb, lsSQL, lQueryMap, laRecords)

Parameter:	hdb	: The handle to a database connection as returned by DB_Connect. HDATABASE.
Parameter:  	lsSQL: SQL query statement in List of STRING format. LIST OF STRING lsSQL
Parameter:  	lQueryMap: SQL Mapping of the Column with the Record values, SQLQUERYMAP. LIST OF SQLQUERYMAP
Parameter:  	laRecords: List of Values/records returned by SQL query. LIST OF ANYTYPE Record.
Returns:  	iCount : Returns the counts of SQL query result. INTEGER

Example:
	[-] // type SQLColumn is record			// Used to store the column's values of the original SQL Table			 
		STRING sCUSTNO
		STRING sCUSTNAME
		STRING sCUSTCITY
		// Note:- This record should be declared outside of the function call

	[+] // LIST OF SQLQUERYMAP lSqlQueryMap = {...}	// Used to map the original SQL column name against the user defined record (ANYTYPE aRecord)
		{"CUSTNO",			"sCUSTNO"}
		{"CUSTNAME",		"sCUSTNAME"}
		{"CUSTCITY",		"sCUSTCITY"}

		// where CUSTNO, CUSTNAME, CUSTCITY etc are the Columns name of the SQL Table
		// where sCUSTNO, sCUSTNAME, sCUSTCITY etc are used to map these above Columns of the SQL Table



	STRING sCon_string 		= "DSN=SQLServerPC011663;SRVR=PC011663;UID=sa;PWD=sa"
	LIST OF STRING lsQuery 		= {"select * from XCUSTOMERS where CUSTNO = 1002","select *from XCUSTOMERS", "select * from XCUSTOMERS where CUSTNO = 1005"}
	LIST OF SQLColumn lSQLColumnData = {...}
	INTEGER iRows 			= 0

	HDATABASE hdbc = DB_Connect (sCon_string)

	DB_QueryAll_Record (hdbc, lsQuery, lSqlQueryMap, lSQLColumnData)

	[+] // for iRows = 1 to ListCount(lSQLColumnData)
		Print(lSQLColumnData[iRows].sCUSTNO)

	[+] // Output:
		Prints the CUSTNO of each record



#####	SQL Formatting functions


Function:	SQL_Translate function
Action:		SQL_Translate searches lsSQL list for the query sFrom. When it finds a match, it replaces sFrom with sTo.
		All instances of sFrom in lsSQL list are replaced, and the new list is modifies with lsSQL
Syntax:		SQL_Translate (lsSQL, sFrom, sTo)
Parameter:	lsSQL	: The original list of SQL query. LIST OF STRING
Parameter:	sFrom	: The SQL query to search from the original list (lsSQL). STRING.
Parameter:	sTo	: The SQL query to be replaced against the  sFrom. STRING.
Returns:	void

Example:
	[+] // LIST OF STRING lsQuery = {...}
		"select * from Persons where P_Id = 901"
		"select * from Persons where P_Id = 101"
		"select *from Employee"

	SQL_Translate(lsQuery, "Persons", "Employee")
	Print (lsQuery)
	[+] // Output
		The output of lsQuery will be
		select * from Employee where P_Id = 901, select * from Employee where P_Id = 101, select *from Employee



Function:	SQL_ListToStr function
Action:		Convert LIST OF SQL queries into a single query of type STRING.
Syntax:		sQuery = SQL_ListToStr (lsSQL)
Parameter:	lsSQL : LIST OF SQL queries. LIST OF STRING.
Returns:	It returns a single query of type STRING.

Example:
	[+] // LIST OF STRING lsQuery = {...}
		"select * from Persons where P_Id = 901"
		"select * from Persons where P_Id = 101"
		"select *from Employee"

	sQuery = SQL_ListToStr (lsSQL)
	[+] // Output

		The output of squery will be
		select * from Persons where P_Id = 901 select * from Persons where P_Id = 101 select *from Employee




Function:	SQL_FormatList function
Action:		Convert each item of lsItems queries with single quotes and places a comma seprater in between each item and -
		- returns it as a single string.
Syntax:		sQuery = SQL_FormatList (lsItems)
Parameter:	lsItems : LIST OF SQL queries / Items. LIST OF STRING.
Returns:	It returns a single query of type STRING.

Example:
	[+] // LIST OF STRING lsQuery = {...}
		"select * from Persons where P_Id = 901"
		"select * from Persons where P_Id = 101"
		"select *from Employee"

	sQuery = SQL_FormatList (lsSQL)
	[+] // Output
		The output of squery will be
		'select * from Persons where P_Id = 901','select * from Persons where P_Id = 101','select *from Employee'



Function:	SQL_ColumnValue_Format  function
Action:		It converts the Column's Value to STRING datatype.
Syntax:		sColValue = SQL_ColumnValue_Format (ColumnValue)
Parameter:	ColumnValue : The SQL table Column's information. SQLCOLUMNVALUE.
Returns:		Returns the column's value which is of type STRING

Example:
	[+] // SQLCOLUMNVALUE ColValue = {...}
		"P_Id"	//Column Name
		901		//Column value
		3		//number of decimal point. This is only applicable if your Column value is REAL. This is optional.
	sColValue = SQL_ColumnValue_Format (ColValue)
	[+] // output
		The output of sColValue will be always of Type STRING irrespective of any datatype.



Function:	SQL_FormatInsert function
Action:		It converts the list of Column Value of a table to a SQL INSERT INTO Statement.
Syntax:		lsInsertQuery = SQL_FormatInsert (sTable, lColumnValue)
Parameter:	sTable : the table name of the SQL database
Parameter: 	lColumnValue : The list of cloumn information of sTable for which INSERT will be done. SQLCOLUMNVALUE.
Returns:	It returns the SQL INSERT INTO Statement. LIST OF STRING.

Example:
	[+] // LIST OF SQLCOLUMNVALUE lColValue = {...}
		{"CUSTNO", 100, 3}
		{"SALARY", 25000.40, 2}


	LIST OF STRING lsInsertQuery = SQL_FormatInsert ("Employee", lColValue)
	ListPrint(lsInsertQuery)
	[+] // output
		The output of lsInsertQuery will be

		INSERT INTO Employee (CUSTNO, SALARY)
		VALUES (100, 25000.40)



Function:	SQL_FormatUpdate function
Action:		It converts the list of Column Value of a table to a SQL UPDATE Statement.
Syntax:		lsInsertQuery = SQL_FormatUpdate (sTable, lColumnValue)
Parameter:	sTable : the table name of the SQL database
Parameter: 	lColumnValue : The list of cloumn information of sTable for which UPDATE will be done. SQLCOLUMNVALUE.
Returns:	It returns the SQL UPDATE Statement. LIST OF STRING.

Example:
	[+] // LIST OF SQLCOLUMNVALUE lColValue = {...}
		{"CUSTNO", 100, 3}
		{"SALARY", 25000.40, 2}


	LIST OF STRING lsInsertQuery = SQL_FormatUpdate ("Employee", lColValue)
	ListPrint(lsInsertQuery)
	[+] // output
		The output of lsInsertQuery will be

		UPDATE Employee
		SET CUSTNO=100, SALARY=25000.40



#####	String manipulation functions


Function:  	FieldsToList function
Action:    	Returns the fields in a delimited string as a list of strings.
Syntax:		lsSegments = FieldsToList (sString, sDelim, [bLogWarning])
Parameter: 	sString: The delimited string to return the segments from. STRING.
Parameter: 	sDelim: The character(s) to use to separate fields in sString. STRING.
Parameter: 	bLogWarning: Log a warning if sDelim not found in sString. Default is FALSE (optional). INTEGER.
Returns:   	lsSegments: The returned segments. LIST OF STRING.


Function:  	ConvertPathTo8CharFormat function
Action:    	Converts a path to 8 char limit mode.
Syntax:		sConvertedPath = ConvertPathTo8CharFormat (sPath)
Parameter: 	sPath: The original path. STRING.
Returns:   	sConvertedPath: The path converted to 8 char parts. STRING.


Function:  	GetFieldReverse function
Action:     	Returns a segment (field) of a string, working backwards from the end of the string.
Syntax:		sSegment = GetFieldReverse (sString, sDelim, iField)
Parameter: 	sString: The string to return a segment from. STRING.
Parameter: 	sDelim: The character(s) to use to separate fields in sString. STRING.
Parameter: 	iField: The occurence of the field to return. INTEGER.
Returns:   	sSegment: The returned segment. STRING.


Function:  	FormatPrecision function
Action:     	Returns a string containing a real number with the specified precision.
Syntax:		sFormatted = FormatPrecision (sToFormat, iDecimalPlaces)
Parameter: 	sToFormat: The real number in string form. STRING.
Parameter: 	iDecimalPlaces: The number of decimal points precision desired. INTEGER.
Returns:   	sFormatted: The formatted string. STRING.


Function:  	Round function
Action:     	Rounds a number to the nearest integer.
Syntax:		iRound = Round (nToRound)
Parameter: 	nToRound: The number to round. NUMBER.
Returns:   	iRound: The nearest integer to the number. INTEGER.


Function:  	RoundDown function
Action:     	Rounds a number to its integer component.
Syntax:		iRound = RoundDown (nToRound)
Parameter: 	nToRound: The number to round. NUMBER.
Returns:   	iRound: The integer portion of the real number. INTEGER.


Function:	StrLen function
Action:		StrLen returns the number of characters in sString. If sString is an empty string (""), StrLen returns 0.
Syntax:		iLength = StrLen ( sStr null)
Parameter:	sStr: [null]. The string whose length to return. STRING.
Returns:	Returns the length of a string [iLength]. INTEGER.


Function:	StrTrim finction
Action:		Strips leading and trailing whitespace from a string.
Syntax:		sStripped = Trim (sToStrip)
Parameter:	sStr: [null] The string to strip. STRING.
Returns:	Trim removes leading and trailing whitespace from a string and returns the rest of the string [sStripped]. STRING.


Function:	StrHasValue function
Action:		Checks whether the specified string has any value or not
Syntax:		bSttHas = StrHasValue ( sStr [null])
Parameter:	sStr: [null]. The string to be checked. STRING.
Returns:	Returns TRUE id the specified string is not equal to NULL or "" else returns FALSE. BOOLEAN.


Function:	StrPadZeroes function
Action:		Pads zeroes at beginning of the string
Syntax:		sNewString = StrPadZeroes ( sStr [null], nWidth)
Parameter:	sStr: [null]. The string to be padded with leading zeroes. STRING.
Parameter:	nWidth: The final width of the string including the leading zeroes. INTEGER.
Returns:	Returns the string [sNewString] with the leading zeroes. STRING.


Function:	StrPadSpaces function
Action:		Pads trailing whitespace characters at end of the string
Syntax:		sNewString = StrPadSpaces ( sStr [null], nWidth)
Parameter:	sStr: [null]. The string to be padded with trailing whitespace characters. STRING.
Parameter:	nWidth: The final width of the string including the trailing whitespace characters. INTEGER.
Returns:	Returns the string [sNewString] with the trailing whitespace characters. STRING.


Function:	StrStripDecimalLeft function
Action:		Stripts the string before the the decimal character.
Syntax:		sNewString = StrStripDecimalLeft ( sStr [null])
Parameter:	sStr: [null]. The string to be striped before the decimal character. STRING.
Returns:	Returns the new string [sNewString] before the decimal character if it found, else returns the original string. STRING.


Function:	StrStripDecimalRight function
Action:		Stripts the string after the the decimal character.
Syntax:		sNewString = StrStripDecimalRight ( sStr [null])
Parameter:	sStr: [null]. The string to be striped after the decimal character. STRING.
Returns:	Returns the new string [sNewString] after the decimal charactor if it found, else returns the original string . STRING.


Function:	StrGetLeftOfSpecialChar function
Action:		Returns the string before a particular character(s).
Syntax:		sNewString = StrGetLeftOfSpecialChar ( sStr [null],  sSplChar)
Parameter:	sStr: [null]. The string to be striped before a particular character(s). STRING.
Parameter:	sSplChar: The special character to be searched in the original string [sStr]. STRING.
Returns:	Returns the new string [sNewString] before a particular character(s) if it found, else returns an empty string (""). STRING.


Function:	StrGetRightOfSpecialChar function
Action:		Returns the string after a particular character(s).
Syntax:		sNewString = StrGetRightOfSpecialChar ( sStr [null],  sSplChar)
Parameter:	sStr: [null]. The string to be striped after a particular character(s). STRING.
Parameter:	sSplChar: The special character to be searched in the original string [sStr]. STRING.
Returns:	Returns the new string [sNewString] after a particular character(s) if it found, else returns an empty string (""). STRING.


Function:	StrStripOutAnyChar function
Action:		Stripts out the specified character from a given string if it has any.
Syntax:		sNewString = StrStripOutAnyChar ( sStr [null], sAnyChar)
Parameter:	sStr: [null]. The string to be striped for a given character. STRING.
Parameter:	sAnyChar: The special character to be Stripted out in the original string [sStr]. STRING.
Returns:	If the said character is found in the original string,
		returns the new string [sNewString] after stripping the character from [sStr] else returns the original string. STRING.


Function:	StrStripLeadingZeros function
Action:		Stripts the Leading Zeros before of a string if it has any.
Syntax:		sNewString = StrStripLeadingZeros ( sStr [null])
Parameter:	sStr: [null]. The string to be striped for Leading Zeros of a string. STRING.
Returns:	Returns the new string [sNewString] after stripping the Leading Zeros. STRING.


Function:	ParseStringList function
Action:		Split the string from a delimiter and store it in a List
Syntax:		lsNewList = ParseStringList ( sStr [null], sDelim)
Parameter:	sStr: [null]. The string to be striped out. STRING.
Parameter:	sDelim: The delimiter from which the string will be splited. STRING.
Returns:	Returns sub-strings in a LIST OF STRING after parsing is done. LIST OF STRING.

Function:	ParseNumber function
Action:		Parses only number from a String
Syntax:		bParse = ParseNumber (sParse, nValue)
Parameter:	sParse: [inout]. The original string to be parsed for a number.
			Once parsing is done the variable sParse value will be modified and will contain the string part only  STRING.
Parameter	nValue: [out]. The variable in which the number will be stored. NUMBER.
Returns:	Returns TRUE if parsing is success else FALSE. BOOLEAN.
